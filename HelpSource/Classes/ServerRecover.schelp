TITLE:: ServerRecover
summary:: Strategies for servers to recover when booting shows port conflicts
categories:: Control
related:: Classes/Server


DESCRIPTION::

When trying to boot a server, the server may find that there is already a process
using the desired port number. This can have several reasons, and several strategies.

* It may be a server zombie from a language crash.
One can recover by hijacking that server, or reboot it.

* It may be an scsynth or supernova program run by another application.
One can recover by switching to a different port number.

* In more complex network music settings, one can add further custom
strategies to ServerRecover.

Code examples:

code::

// test regular boot and accidental quit:
// kill all servers first
unixCmd("killall scsynth supernova");
// server address port is free, could boot now
s.addr.portIsFree;
// regular boot, should work fine
s.boot;
// now simulate server crash with unixCmd, not Server.killAll;
unixCmd("killall scsynth supernova");
s.serverRunning;


// now induce the zombie problem:

unixCmd("killall scsynth supernova");
// start an scsynth instance by hand to simulate a zombie:
x = (Server.program + s.options.asOptionsString(57110)).unixCmd;
// now server port is used, and boot would fail ...
s.addr.portIsFree;

// recover option 1 is 'failAndAsk':
ServerRecover.default.cs;
s.boot;

// recover option 2 is 'hijack' - assumes it is a zombie and reuses that,
ServerRecover.default = \hijack;
// for annoyance, add a dangling note to the zombie
s.addr.sendMsg("/s_new", \default, 1234);
// hijacking sends a freeAll command
s.boot;
s.serverRunning; // it is running now
s.pidRunning;    // but cannot know its pid

////////////// HERE hijacked server does not find out it is dead! ///////////
unixCmd("killall scsynth supernova");
s.serverRunning; // still thinks it is running -why?
s.pidRunning;    // but does not know its pid


// option 3 is 'reboot' - this is safer. kill the old scsynth, boot the server
// create zombie first
s.quit;
x = (Server.program + s.options.asOptionsString(57110)).unixCmd;
ServerRecover.default = \reboot;
s.boot;

////////////// HERE \reboot post TWICE - why? /////////////

// option 3 is 'useFreePort' - this is more polite:
// other programs on this machine may use port 57110,
// for instance to run scsynth instances at the default port.
// 'useFreePort'  finds a free port number, and boots server with that port.
// Switching to a free port number by hand would also work.
unixCmd("killall scsynth supernova");
x = (Server.program + s.options.asOptionsString(57110)).unixCmd;
ServerRecover.default = \useFreePort;
s.boot;

// test case for multi-servers:

(
// make sure there are no scsynth processed around
unixCmd("killall scsynth supernova");
// Start three servers, as if by other programs, or zombies
x = (Server.program + s.options.asOptionsString(57110)).unixCmd;
x = (Server.program + s.options.asOptionsString(57109)).unixCmd;
x = (Server.program + s.options.asOptionsString(57108)).unixCmd;
)

ServerRecover.default = \useFreePort;
s.boot;
s.addr; // moved port out of the way.


::

CLASSMETHODS::

METHOD:: default
the name of the default strategy to use

METHOD:: bootStrategies
a dictionary of all the strategies

METHOD:: at
argument:: key
get strategy at key, or default.

