title:: Remote Servers
categories:: Server
summary:: How to use remote servers
related:: Classes/Server, Classes/NetAddr

TO DO:
* Ndef.end tries to free wrong nodeIDs, see below

code::

// set up a multichannel server for several clients
(
s.options.numInputBusChannels = 8;
s.options.numOutputBusChannels = 8;
s.options.numAudioBusChannels;
s.options.numPublicAudioBusChannels;
s.options.numPrivateAudioBusChannels;
s.options.firstPrivateBus;

s.options.maxLogins = 32;
)

// Q: maybe options should know their servers,
//    and inform/warn what can't be changed after server is booted?

// set clientID before booting.
// (can also be changed after server is booted, but may lose track of id ranges)
s.clientID = 0; // default
s.clientID = 2; // informs about change
s.clientID = (s.options.maxLogins - 1).postln; // highest possible id

// refuses for different reasons
s.clientID = \abc; // illegal
s.clientID = -1;
s.clientID = 32;


// test lots of remote clients:
s.options.maxLogins = 200;
s.clientID = 200.rand;


// back to 32
s.options.maxLogins = 32; s.clientID = 0;
s.boot;
s.queryAllNodes; // default group nodeID is clientID

s.makeWindow; s.window.alwaysOnTop_(true);
s.volume.volume_(-3);
s.scope;
s.queryAllNodes; // default group nodeID is clientID
s.defaultGroup.queryTree; // query just my group

// three ways to make sound, all go to s.defaultGroup, 1
x = { Saw.ar(330) * 0.1 }.play(s);
s.queryAllNodes;
e = (amp: 0.2, dur: inf, group: 1).play;
s.queryAllNodes;
Ndef(\noyz, { BrownNoise.ar([0.1, 0.1]) }).play;
s.queryAllNodes;
s.defaultGroup.queryTree; // query just my group

// turn them off again
e.release;
x.free;
Ndef(\noyz).end;

// first private audio bus
Ndef(\noyz).bus;

/*
// Ndef(\noyz).end; line posts this - find cause and remove:
FAILURE IN SERVER /n_set Node 1003 not found
FAILURE IN SERVER /n_free Node 1003 not found
*/

// now simulate a remote client by creating
// a second server object, as if it were remote:
// give it a clientID by hand to test:
r = Server.remote(\pseudo12, s.addr, s.options.copy, 12);
r.defaultGroup; // group 12, like clientID
r.queryAllNodes; // group 12 present on server

r.boot; // reports already running
n = NodeProxy.audio(r, 2);
n.bus; // bus alloc is 4 private buses + 384 offset

r.makeWindow; r.window.alwaysOnTop_(true);
	// window shows same data as s.window,
	// except volume is not synced
// Q: should volume move to defaultGroup, not rootnode?

s.queryAllNodes; // sees all nodes of all clients on server
r.queryAllNodes; // same for remote server

// same three ways to make sound, all go to group 12 now
s.defaultGroup.queryTree;
r.defaultGroup.queryTree;

y = { Saw.ar * 0.1 }.play(r);
r.queryAllNodes;
e = (amp: 0.2, dur: inf, server: r).play;
r.queryAllNodes;
// Ndef always goes to group 1 - find where that happens.
n = Ndef(\noyz -> r.name);
n.play;
n.bus;

n.source = { Dust.ar([20, 20]) };
s.queryAllNodes;

// check what these are
n.parentGroup; // server defaultGroup
n.group; // proxy's own group

// compare nodes in the two defaultGroups
s.defaultGroup.queryTree;
r.defaultGroup.queryTree;
// turn them off again
e.release;
y.free;
Ndef(\noyz -> r.name).end;
s.queryAllNodes;

// buffers work on either server
p = Platform.resourceDir +/+ "sounds/a11wlk01.wav";
a = Buffer.read(s, p);
a.play;

s.queryAllNodes;

b = Buffer.read(r, p);
b.play;
s.queryAllNodes;
::

